;;; -*- Mode: TDL; Package: DISCO -*-
;;;
;;;  HPSG Grammar Matrix Version 0.1
;;;
;;;  Copyright Emily M. Bender 2002
;;;  All Rights Reserved.
;;;  No use or redistribution without permission.
;;;  
;;;  Based on:
;;;
;;;  LinGO Grammar: fundamentals.tdl 
;;;  Copyright Daniel Flickinger 1994-2001
;;;  Initial development Rob Malouf, 3-Nov-1994
;;;
;;;  JACY Grammar: fundamentals.tdl, mrsbasic.tdl
;;;  Developed by Melanie Siegel, Emily M. Bender

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Basic types

sort := *top*.
atom := sort.
avm := *top*.
list := avm.

cons := list &
	[ FIRST *top*,
	  REST *top* ].

0-1-list := list.
1-list := 0-1-list & cons &
  [ REST null ].
null := 0-1-list.
1-plus-list := cons &
  [ REST cons ].

diff-list := avm &
[ LIST list,
  LAST list ].

0-1-dlist := diff-list &
  [ LIST 0-1-list ].
0-dlist := 0-1-dlist &
  [ LIST #list,
    LAST #list ].
1-dlist := 0-1-dlist &
  [ LIST 1-list &
	 [ REST #rest & null ],
    LAST #rest ].


; This type shows the basic form for diff-list appends.
; It is not meant to be used as a supertype.  Actual instances
; of diff-list append will involve different features in different
; relationships to each other & the feature geometry.

dl-append := avm & [APPARG1 [LIST #first,       
			       LAST #between],
		      APPARG2 [LIST #between,
			       LAST #last],
		      RESULT  [LIST #first,
			       LAST #last]].

symbol := atom.
integer := atom.
string := symbol.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
;;
;;  Top-level feature geometry
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Types for Sign, Word, Phrase, and Lex-Entry

sign-min := avm &
  [ STEM list ].

basic-sign := sign-min &
  [ KEY-ARG bool ].

sign := basic-sign &
  [ SYNSEM synsem,
    ARGS list,
    INFLECTED bool,
    ROOT bool ].

; C-CONT encodes the semantic contribution of the rule (phrasal
; or lexical).

phrase-or-lexrule := sign &
  [ SYNSEM canonical-synsem &
	   [ LOCAL.CONT [ TOP #hand,
			  INDEX #index,
                          E-INDEX #event ] ],
    C-CONT mrs-min & [ TOP #hand,
		       INDEX #index,
                       E-INDEX #event ] ].

word-or-lexrule-min := sign-min.

; ALTS allow lexical entries to block lexical rule application
word-or-lexrule := word-or-lexrule-min & sign &
  [ ALTS alts-min ].

alts-min := avm.
alts := alts-min &
  [ PASSIVE bool ].
no-alts := alts-min.

; Not all words have lex-synsem - e.g. lexical PPs like "tomorrow" are
; phr-synsem since they can be post-nominal modifiers.

word := word-or-lexrule &
  [ SYNSEM.LOCAL.CONT [ TOP #hand,
			--TOPKEY.HNDL #hand ],
    ROOT - ].

;; Not all phrases have SYNSEM phr-synsem, since we need to allow the
;; head-comp rules to build signs which are still [ SYNSEM lex-synsem
;; ], for constructions like "twenty-two" and "five fifteen p.m.".  So
;; most phrases will assign the type phr-synsem to the value of
;; SYNSEM, but not all.

; Phrases don't have argument structure, but ARG-S is a feature
; of local, not sign.  So rather than have subtypes of local for
; phrases and lexical items, constrain phrases to have empty ARG-S.

phrase := phrase-or-lexrule &
  [ SYNSEM.LOCAL.ARG-S < >,
    ROOT bool ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Affixation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

non-affix-bearing := word-or-lexrule &
[ INFLECTED +,
  SYNSEM.LOCAL.KEYS.KEY.LABEL cons ].

; Rule

rule := sign &
  [ RULE-NAME symbol ].

; LABEL-NAME and META used for labeling nodes in parse trees

tree-node-label := *top* &
  [ NODE sign ].

label := sign &
  [ LABEL-NAME string ].

;; see lkbpatches
meta := sign &
  [ META-PREFIX string,
    META-SUFFIX string ]. 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SYNSEM values

synsem-min := avm &
  [ OPT bool,
    LOCAL mod-local,
    NON-LOCAL non-local-min ].

lex-or-phrase-synsem := synsem-min &
  [ LEX bool ].

synsem := synsem-min.

expressed-synsem := synsem.

canonical-synsem := expressed-synsem &
  [ MODIFIED xmod ].

lex-synsem := canonical-synsem & lex-or-phrase-synsem &
  [ LOCAL local-min,
    LEX + ].

phr-synsem := canonical-synsem & lex-or-phrase-synsem &
  [ LOCAL local-min,
    LEX - ].

non-canonical := synsem &
  [ LOCAL.CONT.INDEX non-expl ].

expressed-non-canonical := non-canonical & expressed-synsem.

gap := expressed-non-canonical &
  [ LOCAL #local,
    NON-LOCAL [ REL 0-dlist,
		QUE 0-dlist,
		SLASH 1-dlist &
		    [ LIST < #local > ] ] ].

unexpressed := synsem-min &
  [ NON-LOCAL [ SLASH 0-dlist,
		REL 0-dlist,
		QUE 0-dlist ] ].

unexpressed-reg := unexpressed & non-canonical.

anti-synsem := unexpressed.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LOCAL & NON-LOCAL values

; The feature AGR is introduced on LOCAL rather than on CAT (or on HEAD) since
; coordination schema unify the CAT value of the daughters with that of then
; mother, but need to be able to change AGR on the mother (to get plural 
; agreement on verb when subject is a coordinated NP with "and" vs. "or").  

mod-local := avm.

local-min := mod-local &
  [ CAT cat-min,
    CONT mrs-min,
    AGR individual ].

local-basic := local-min &
  [ KEYS keys-min ].

local := local-basic &
  [ CTXT ctxt-min,
    ARG-S list ].

; Types for distinguishing scopal v. intersective modifiers.
; (These types are used in the MOD value of modifiers, and 
; references by the scopal/intersective head-adjunct rules.)

scopal-mod := local.
intersective-mod := local.

non-local-min := avm.

non-local := non-local-min &
  [ SLASH 0-1-dlist,
    QUE 0-1-dlist,
    REL 0-1-dlist ].

non-local-none := non-local &
  [ SLASH 0-dlist & [ LIST < > ],
    QUE 0-dlist,
    REL 0-dlist ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  CAT values

cat-min := avm.

cat := cat-min &
  [ HEAD head-min,
    VAL valence-min,
    MC luk,
    POSTHEAD bool ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  HEAD & VAL 

head-min := avm.

; It is expected that head will have many more features, but it
; is not yet clear which are relevant crosslinguistically.  In
; the English grammar, HEAD features include CASE, PRD, AUX, INV,
; TAM, and VFORM.  (Re: TAM --- it is sometimes useful to have the
; semantic information encoded in EVENT.E accessible via the head
; path.)

; Which subtypes of head are necessary and which head features are
; declared for which subtypes is also a language-specific question.

head := head-min &
  [ MOD list ].

valence-min := avm.

valence := valence-min &
  [ SUBJ list,
    SPR list,
    COMPS list,
    SPEC list,
    --KEYCOMP avm ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CONT values
;
;   TOP handle,            ; Local top handle, linked by H-CONS 
;                          ; to other handles
;   H-CONS diff-list       ; Scope constraints: list of qeq's
;   LISZT diff-list        ; List of semantic relations

mrs-min := avm &
  [ INDEX individual,
    E-INDEX individual ].

mrs-min0 := mrs-min &
  [ TOP handle ].

mrs-min1 := mrs-min0 &
  [ LISZT diff-list,
    --TOPKEY relation ].
    
mrs := mrs-min1 &
  [ H-CONS diff-list ].

; Mrss are divided into psoas (with a distinguished event) and
; nom-objs (with a distinguished index).  We use a polymorphic
; attribute name INDEX for both of these, to simplify manipulation of
; these objects; for example, modifying PPs assign as their ARG's
; value the INDEX of the phrase they modify, whether it's an N-bar
; (with a ref-ind value) or a VP (with an event value).  Similarly
; useful for coordination.

psoa := mrs-min &
  [ INDEX event ].

psoa-basicmrs := psoa & mrs-min0.

psoa-mrs := psoa-basicmrs & mrs.

nom-obj := mrs-min &
  [ INDEX index ].

nom-obj-basicmrs := nom-obj & mrs-min0.

nom-obj-mrs := nom-obj-basicmrs & mrs.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; KEY relations, for semantic selection
;  KEY relation             ; Pointer to main relation in LISZT
;  ALTKEY relation          ; Pointer to an alternate relation in LISZT
;  --COMPKEY relation       ; Pointer to the complement's main relation
;  --OCOMPKEY relation      ; Pointer to the oblique complement's main relation
;
;  MESSAGE 0-1-dlist,       ; Message type for clauses


keys-min := avm.

keys-k := keys-min &
  [ KEY relation ].

keys-km := keys-k &
  [ MESSAGE 0-1-dlist ].

keys := keys-km &
  [ ALTKEY relation,
    --COMPKEY relation,
    --OCOMPKEY relation ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  CTXT values 

ctxt-min := avm.

ctxt := ctxt-min &
  [ ACTIVATED bool,
    PRESUP diff-list ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Basic semantic types

; The message represents the semantic type of a clause (cf. Ginzburg &
; Sag 2000).  All clauses have messages.  Elements that take clauses
; as semantic arguments should end up with the HNDL of the clause as
; the value of ARG4, L/R-HNDL, MAIN, SUBORD, etc.  The SOA of a message
; is a handle that qeqs the HNDL of the main verb in the clause.
; This leaves room for quantifiers to scope at each clause without
; allowing scope ambiguity between quanitifers and messages, as it is
; not clear what that would mean.

message := norm-relation &
  [ SOA handle ].
command := message.
prop-or-ques := message.          ;for COMPS of e.g. 'know'
proposition := prop-or-ques.
abstr-ques := prop-or-ques.       
question := abstr-ques.

; Subtype of int-rel for tag questions and structures in other languages
; with equivalent pragmatics.
ne-rel := abstr-ques.                 

; Constrains handle of scopable argument SC-ARG relative to one 
; OUTSCPD handle.

qeq := avm &
  [ SC-ARG handle,
    OUTSCPD handle ].        

mrs-thing := avm &
  [ INSTLOC instloc ].
instloc := *top*.

handle := mrs-thing.
individual := mrs-thing.

; The INDEX value of a nom-obj is an index (expletive or
; referential).

index := individual.

; This is the type of the index of the phrase modified by predicative
; PPs, which can either modify a ref-ind nominal or an event VP.

non-expl := individual.
event-or-ref-index := non-expl & index.

; Expletives get distinguished index type so they can be
; selected semantically.  In English, this type has subtypes
; for it and there.  Most languages have at most one expletive,
; so those aren't included here.

expl-ind := index.
ref-ind := event-or-ref-index &
  [ PNG png ].

; Types encoding agreement information, analyzed as a part of the
; index, following Pollard & Sag 1994.  Which subtypes and features
; are appropriate seems highly language dependent.  The agreement
; system of English doesn't justify a full cross-classification of
; number and gender, so the features of png are PN and GENDER in the
; English grammar.  (See Flickinger 2000.) Sag & Wasow 1999 declare
; GENDER as a feature of the png type 3sg.

png := avm.

; Create subtypes of tense, aspect and mood as appropriate.

tense := sort.
aspect := sort.
mood := sort.

tam := avm &
 [ TENSE tense,
   ASPECT aspect,
   MOOD mood ]. 

event := event-or-ref-index &
  [ E tam ].

; Coordinated phrases have conjoined indices as their INDEX
; values.  These are meant to be interpreted as pointers to 
; the set of indices the conjunction conjoins.

conj-ind := event-or-ref-index.
conj-event := conj-ind & event.
conj-ref-ind := conj-ind & ref-ind.


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Basic relation types

; Relations are classified according to the types of arguments they take.  All
; relations have a handle.  In addition, quantifier relations have a bound
; variable and a restriction, nominal relations have an instance, and event
; relations have an event.  Furthermore, nominal relations and event relations
; can have additional roles, depending on their meaning.

; LABEL links semantic relation to input string elements, more or less.
; This becomes useful whenever a grammar is used in some application.

relation := avm &
  [ HNDL handle,
    LABEL list,
    PRED string ].

; no-relation contrasts with all other relations.

norm-relation := relation.
no-relation := relation.

; Abstract relation subtypes.  We recommend not positing a type
; for each lexical relation, but rather using the feature PRED
; to distinguish different lexical relations of the same type.
; Relation types are modified in one of two circumstances:
;
; (i) A feature needs to be introduced that is relevant for some
; relations and not others, or
;
; (ii) Something in the grammar needs to make reference to a family
; of relations that are not otherwise distinguished by a type.


verb-prep-rel := norm-relation & 
                 [EVENT event].

event-rel := verb-prep-rel.
v-event-rel := event-rel.
arg-rel := norm-relation &
           [ ARG mrs-thing ].
arg-event-rel := arg-rel & event-rel.
arg1-rel := v-event-rel &
            [ARG1 ref-ind].

; The purpose of arg3-rel-super is allow for a type that includes all
; verbs and no prepositions/modifiers.  Since Ps have ARG3, this can't
; in a subtype of v-event-rel.  The specialization to ARG3 ref-ind for
; Ps will be on argmod3-rel.

arg3-rel-super := event-rel &
                  [ ARG3 mrs-thing ].
arg3-rel  := arg3-rel-super & v-event-rel &
            [ARG3 ref-ind].

; For nominalizing predicates.

arg4-rel-super := norm-relation &
                  [ ARG4 mrs-thing ].
arg4-rel := v-event-rel & arg4-rel-super.
arg12-rel :=  arg1-rel &
            [ARG2 ref-ind ].
arg123-rel :=  arg12-rel & arg13-rel.
arg13-rel  :=  arg1-rel & arg3-rel.
arg14-rel := arg1-rel & arg4-rel.
arg124-rel := arg12-rel & arg14-rel.
arg134-rel := arg13-rel & arg14-rel.
arg1234-rel := arg123-rel & arg124-rel & arg134-rel.

; unaccusative verbs

arg3only-rel := arg3-rel.

argmod3-rel := arg-rel & arg3-rel-super.
verb-ellipsis-rel := arg1-rel.

; Preposition relations

prep-mod-rel := argmod3-rel.

; adverb relations

adv-rel := arg-event-rel.
neg-rel := adv-rel.

; subordination and coordinating conjunctions

subord-or-conjunction-rel := norm-relation &
                             [L-HNDL handle,
                              R-HNDL handle ].

conjunction-rel := subord-or-conjunction-rel &
                   [C-ARG conj-ind,
                    L-INDEX index,
                    R-INDEX index].

subord-rel := subord-or-conjunction-rel.
if-then-rel := subord-rel & [PRED 'if-then-rel].

; noun noun compounds

unspec-compound-rel := norm-relation &
  [ HINST index,
    NHINST index ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Head types

; Values for head features such as CASE, VFORM, ...

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Sorts for atomic values

; person, number and gender

; clause mode

; voice

; mood

; pronoun type

; Three-valued sort evoking Polish logician Jan Lukasiewicz

luk := sort.

; These types allow the statement of constraints (e.g., in 
; subcategorization) of the form:  If you care, you must have
; the value + (-), but you don't have to care.  Useful for keeping
; down the number of constructions and subcategorization types.

na-or-+ := luk.
na-or-- := luk.

na := na-or-+ & na-or--.
bool := luk.
+ := bool & na-or-+.
- := bool & na-or--.

; Three-valued sort for distinguishing unmodified signs from both
; left-modified and right-modified signs PERIPH indicates whether this
; modifier is left- or right-peripheral in its phrase - e.g., "the IBM
; temporary employees" but "*the IBM five employees"

xmod := sort &
  [ PERIPH luk ].
notmod-or-rmod := xmod.
notmod-or-lmod := xmod.
notmod := notmod-or-rmod & notmod-or-lmod.

hasmod := xmod.
lmod := hasmod & notmod-or-lmod.
rmod := hasmod & notmod-or-rmod.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Some useful kinds of lists

; A list of optional arguments.

olist := list.

ocons := olist & cons &
  [ FIRST unexpressed & [ OPT + ],
    REST  olist ].

onull := olist & null.

; The LinGO grammar also makes use of a prolist -- or list
; of synsems of type pro-ss. 


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Lexical rules

lex-rule := phrase-or-lexrule & word-or-lexrule &
  [ NEEDS-AFFIX bool,
    DTR [ SYNSEM.LOCAL.CONT.LISZT [ LIST #middle,
				    LAST #last ],
	  ALTS #alts ],
    SYNSEM.LOCAL.CONT.LISZT [ LIST #first,
			      LAST #last ],
    C-CONT.LISZT [ LIST #first,
		   LAST #middle ],
    ALTS #alts ].

; Supertype for inflectional lexical rules (these apply first).

lex-rule-affix := lex-rule &
  [ INFLECTED +,
    KEY-ARG #keyarg,   
    SYNSEM #synsem,
    ARGS < #dtr >,
    ROOT #root,
    DTR #dtr & [ INFLECTED -,
                 KEY-ARG #keyarg,   
                 SYNSEM #synsem,
                 ROOT #root ],
    C-CONT.LISZT <! !> ].

; Supertype for lexical rules without any morphophonological effect.

lex-rule-silent := lex-rule &
  [ DTR word-or-lexrule & #stem &
	[ SYNSEM.LOCAL [ CAT [ MC #mc ],
			 KEYS.MESSAGE #msg ],
	  INFLECTED + ],
    SYNSEM.LOCAL [ CAT [ MC #mc ],
		   KEYS.MESSAGE #msg ],
    INFLECTED +,
    ARGS < #stem > ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Phrase structure rules

; Headed phrases must obey the Head Feature Principle and the Revised
; Marking Principle.  They do not all obey the NLFP with respect to
; QUE, but it appears that all CLAUSE phrases account for QUE on
; mother and non-head-dtr.  Hence moved the QUE coreference to
; NON-CLAUSE.  Headed phrases also identify the value of AGR on mother
; and head daughter, unlike e.g. the coordination schemata which
; identify HEAD but not AGR.

headed-phrase := phrase & 
  [ ROOT -,
    SYNSEM.LOCAL [ CAT [ HEAD head & #head ],
                   AGR #agr,
		   KEYS.KEY #key ],
    HEAD-DTR.SYNSEM.LOCAL local &
		 [ CAT [ HEAD #head ],
                   AGR #agr,
		   KEYS.KEY #key ] ].

non-headed-phrase := phrase &
  [ ROOT - ].

; Most but not all phrases have SYNSEM phr-synsem; head-complement
; constructions have their SYNSEM type determined by the head-dtr.

phrasal := phrase &
  [ SYNSEM phr-synsem ].

; Head/nexus phrases pass up the REL and QUE values of the head daughter
; (which has amalgamated the REL and QUE values of its arguments as in
; Sag 1997) to the mother.  

head-nexus-rel-phrase := headed-phrase &
  [ SYNSEM.NON-LOCAL.REL #rel,
    HEAD-DTR.SYNSEM.NON-LOCAL.REL #rel ].

head-nexus-que-phrase := headed-phrase &
  [ SYNSEM.NON-LOCAL.QUE #que,
    HEAD-DTR.SYNSEM.NON-LOCAL.QUE #que ].

head-nexus-phrase := head-nexus-rel-phrase & head-nexus-que-phrase.

; In a head/local dependent phrase, the SLASH feature of the mother is
; token-identical to that of the head daughter, which has already amalgamated
; the SLASH values of its arguments.  See discussion of head-nexus-phrase for
; treatment of REL and QUE.

head-valence-phrase := head-nexus-phrase &
  [ SYNSEM.NON-LOCAL.SLASH #slash,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #slash ].

; All phrases are either unary or binary.

basic-unary-phrase := phrase &
  [ STEM #stem,
    SYNSEM.LOCAL.CONT [ LISZT [ LIST #first,
				LAST #last ],
			H-CONS [ LIST #scfirst,
				 LAST #sclast ] ],
    C-CONT [ LISZT [ LIST #middle,
		     LAST #last ],
	     H-CONS [ LIST #scmiddle,
		      LAST #sclast ] ],
    ARGS < sign & [ STEM #stem,
                    SYNSEM.LOCAL local &
				 [ CONT [ LISZT [ LIST #first,
						  LAST #middle ],
					  H-CONS [ LIST #scfirst,
						   LAST #scmiddle ] ] ],
                    ROOT - ] > ].

unary-phrase := basic-unary-phrase &
  [ INFLECTED +,
    ARGS < [ INFLECTED + ] > ].

basic-binary-phrase := phrase &
  [ SYNSEM.LOCAL.CONT [ LISZT [ LIST #first,
				LAST #last ],
			H-CONS [ LIST #scfirst,
				 LAST #sclast ] ],
    C-CONT [ LISZT [ LIST #middle2,
		     LAST #last ],
	     H-CONS [ LIST #scmiddle2,
		      LAST #sclast ] ],
    ARGS < sign & [ SYNSEM.LOCAL local &
				 [ CONT [ LISZT [ LIST #first,
						  LAST #middle1 ],
					  H-CONS [ LIST #scfirst,
						   LAST #scmiddle1 ] ] ],
                    ROOT - ],
	   sign & [ SYNSEM.LOCAL local &
				 [ CONT [ LISZT [ LIST #middle1,
						  LAST #middle2 ],
					  H-CONS [ LIST #scmiddle1,
						   LAST #scmiddle2 ] ] ],
                    ROOT - ] > ].

binary-phrase := basic-binary-phrase &
  [ INFLECTED +,
    ARGS < [ INFLECTED + ],
           [ INFLECTED + ] > ].

basic-binary-headed-phrase := headed-phrase & basic-binary-phrase &
  [ NON-HEAD-DTR sign ].

binary-headed-phrase := basic-binary-headed-phrase & binary-phrase.

; For more effecient parsing, designate one argument or the other
; as the KEY-ARG: that which should be unified with first.

binary-rule-left-to-right := rule &
  [ ARGS < [ KEY-ARG + ] , [ KEY-ARG bool ] > ].

binary-rule-right-to-left := rule &
  [ ARGS < [ KEY-ARG bool ], [ KEY-ARG + ] > ].

head-only := unary-phrase & headed-phrase &
  [ HEAD-DTR #head,
    ARGS < #head > ].

head-initial := binary-headed-phrase &
  [ HEAD-DTR #head,
    NON-HEAD-DTR #non-head,
    ARGS < #head, #non-head > ].

basic-head-final := basic-binary-headed-phrase &
  [ HEAD-DTR #head,
    NON-HEAD-DTR #non-head,
    ARGS < #non-head, #head > ].

head-final := basic-head-final & binary-headed-phrase.

; C-CONT is the semantic contribution of the phrase itself.  The handle and
; index of the phrase come from the handle and index of C-CONT (which are
; possibly but not necessarily identified with the handle and index of one of
; the daughters).  The liszt of the phrase is the append of the liszt of
; C-CONT and the liszts of the daughters.

head-compositional := headed-phrase &
  [ C-CONT [ TOP #hand,
	     INDEX #index ],
    HEAD-DTR.SYNSEM.LOCAL.CONT [ TOP #hand,
                                 INDEX #index ] ].

; Clauses have non-empty message values, non-clauses don't.
; Constrain the HEAD value of clause to verb or whatever type is
; appropriate.  Clauses have empty QUE values.
; Later versions of the matrix might have clause v. non-clause as
; an independent dimension from headed v. non-headed phrase, as in
; Ginzburg & Sag 2000.  The phrase types are meant to cross-classify
; with the clause types to give e.g., decl-head-subj from decl-clause
; and head-subj-phrase.  

non-clause := head-nexus-phrase &
  [ SYNSEM.LOCAL [ CAT.MC na,
		   KEYS.MESSAGE 0-dlist ] ].

clause := phrasal &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS olist,
	     NON-LOCAL.QUE 0-dlist ] ].

; The following subtypes of clause will need more constraints,
; as appropriate:

; Relative clauses are propositions, but depending on the analysis
; of the construction, the message may actually come from the daughter.

relative-clause := clause.
  
non-rel-clause := headed-phrase & clause &
  [ SYNSEM [ LOCAL.KEYS.MESSAGE 1-dlist &
			  <! message & #msg &
				   [ HNDL #mhand,
				     SOA #soahand ] !>,
	     NON-LOCAL.REL 0-dlist ],
    HEAD-DTR.SYNSEM [ LOCAL.CONT [ TOP #hdhand,
				   INDEX #ind ],
		      NON-LOCAL [ QUE 0-dlist,
				  REL 0-dlist ] ],
    C-CONT [ TOP #mhand,
	     INDEX #ind,
	     LISZT.LIST < #msg, ... >,
	     H-CONS.LIST < qeq &
                           [ SC-ARG #soahand,
                             OUTSCPD #hdhand ], ... > ] ].


interrogative-clause := clause &
  [ SYNSEM.LOCAL.KEYS.MESSAGE <! question !> ].

declarative-clause := clause &
  [ SYNSEM.LOCAL.KEYS.MESSAGE <! proposition !> ].

imperative-clause := clause &
  [ SYNSEM.LOCAL.KEYS.MESSAGE <! command !> ].

basic-head-filler-phrase := binary-phrase & phrasal &
  [ SYNSEM [ LOCAL [ CAT [ VAL [ COMPS < >,
                                 SPR < anti-synsem > ],
			   POSTHEAD + ] ],
	     NON-LOCAL.SLASH 0-dlist ],
    ARGS < [ SYNSEM [ LOCAL #slash & local &
			    [ CAT.VAL [ SUBJ olist,
					COMPS olist,
					SPR olist ],
			      CTXT.ACTIVATED + ],
		      NON-LOCAL.SLASH 0-dlist ] ],
	   [ SYNSEM [ LOCAL.CAT [ VAL.COMPS olist ],
		      NON-LOCAL [ SLASH 1-dlist &
					[ LIST [ FIRST #slash,
						 REST < > & #last ],
					  LAST #last ],
				  QUE 0-dlist,
				  REL 0-dlist ] ] ] > ].

; These phrase types should all inherit from head-final or head-initial,
; as appropriate, replacing binary-headed-phrase.

basic-head-subj-phrase := head-valence-phrase & head-compositional & 
			  binary-headed-phrase &
  [ SYNSEM.LOCAL [ CAT [ POSTHEAD +,
			 VAL [ SUBJ olist & < anti-synsem >,
			       COMPS < >,
                               SPR #spr ] ],
                   KEYS.ALTKEY #altkey ],
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ VAL [ SUBJ < #synsem >,
                                        SPR #spr,
                                        COMPS olist ],
                                  MC na ],
                            KEYS.ALTKEY #altkey ],
    NON-HEAD-DTR.SYNSEM #synsem & canonical-synsem &
		 [ LOCAL [ CAT [ VAL [ SUBJ olist,
				       COMPS olist,
				       SPR olist ] ] ],
		   NON-LOCAL [ SLASH 0-dlist & [ LIST < > ],
			       REL 0-dlist,
			       QUE 0-dlist ] ] ].

basic-head-spec-phrase := head-valence-phrase & non-clause & phrasal &
			  binary-headed-phrase &
  [ INFLECTED +,
    SYNSEM [ LOCAL [ CAT [ VAL [ SUBJ #subj,
				 COMPS #spcomps,
				 SPR #spr,
				 SPEC #spec ],
			   POSTHEAD #ph ],
		     KEYS.ALTKEY #altkey ],
	     MODIFIED #modif ],
    HEAD-DTR [ INFLECTED +,
               SYNSEM [ LOCAL [ CAT [ HEAD #head,
				    VAL [ SUBJ #subj,
					  COMPS olist & #comps,
					  SPR < #synsem & 
						 canonical-synsem . #spr >,
					  SPEC #spec ],
				    POSTHEAD #ph,
				    MC na ],
			      CONT [ TOP #htop,
				     INDEX #ind ],
			      KEYS [ KEY #key,
                                     ALTKEY #altkey ] ],
		      MODIFIED #hmodif ] ],
    NON-HEAD-DTR.SYNSEM #synsem &
	 [ LOCAL [ CAT [ MC na,
                         VAL [ SPEC < [ LOCAL [ CAT [ HEAD #head,
                                                      VAL.COMPS #comps ],
                                                KEYS.KEY #key,
                                                CONT [ TOP #htop,
                                                       INDEX #ind ] ],
                                        MODIFIED #hmodif ] >,
                               COMPS #spcomps ] ],
                   CONT.TOP #top ],
           MODIFIED #modif ],
    C-CONT [ TOP #top,
             INDEX #ind,
             LISZT <! !>,
	     H-CONS <! !> ] ].

basic-head-comp-phrase := head-valence-phrase & head-compositional &
			  binary-headed-phrase &
  [ SYNSEM canonical-synsem &
	   [ LOCAL [ CAT [ MC #mc,
			   VAL [ SUBJ #subj,
				 COMPS #comps,
				 SPR #spr ],
			   POSTHEAD #ph ],
		     KEYS [ ALTKEY #altkey,
			    MESSAGE #hmsg ] ],
	     LEX #lex ],
    HEAD-DTR.SYNSEM [ LOCAL [ CAT [ MC #mc,
				    VAL [ SUBJ #subj,
					  COMPS < #synsem . #comps >,
					  SPR #spr ],
				    POSTHEAD #ph ],
			      KEYS [ ALTKEY #altkey,
				     MESSAGE #hmsg ] ],
		      LEX #lex ], 
    NON-HEAD-DTR.SYNSEM #synsem & canonical-synsem,
    C-CONT [ LISZT <! !>,
	     H-CONS <! !> ] ].

; Skip an optional complement as long as there is still another obligatory
; complement on the list.  Two subtypes allow for one or two optional
; complements before an obligatory one.

basic-head-opt-comp-phrase := head-valence-phrase & basic-unary-phrase & 
                              head-compositional &
  [ INFLECTED #infl,
    SYNSEM canonical-synsem &
	   [ LOCAL [ CAT [ VAL [ SUBJ #subj,
				 SPR #spr,
                                 SPEC #spec ],
                           MC #mc,
                           POSTHEAD #ph ],
		     KEYS [ ALTKEY #altkey,
                            MESSAGE #msg ] ],
             MODIFIED #mod ],
    HEAD-DTR #head & 
           [ INFLECTED #infl,
             SYNSEM [ LOCAL [ CAT [ VAL [ SUBJ #subj,
					  SPR #spr,
                                          SPEC #spec ],
                                    MC #mc,
                                    POSTHEAD #ph ],
                              KEYS [ MESSAGE #msg,
                                     ALTKEY #altkey ] ],
                      MODIFIED #mod ] ],
    C-CONT [ LISZT <! !>,
	     H-CONS <! !> ],
    ARGS < #head > ].

basic-head-opt-one-comp-phrase := basic-head-opt-comp-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS #comps,
    HEAD-DTR [ INFLECTED +,
               SYNSEM.LOCAL [ CAT.VAL.COMPS 
                                     < unexpressed & [ OPT + ]
                                       . #comps & < expressed-synsem, ... > >,
                              KEYS.KEY event-rel ] ] ].

basic-head-opt-two-comp-phrase := basic-head-opt-comp-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS #comps,
    HEAD-DTR [ INFLECTED +,
               SYNSEM.LOCAL [ CAT.VAL.COMPS 
                                < unexpressed & [ OPT + ]
                                  . < unexpressed & [ OPT + ]
                                      . #comps & < expressed-synsem, ... > > >,
                              KEYS.KEY event-rel ] ] ].


; Unary rules for extraction

basic-extracted-arg-phrase := head-valence-phrase & head-only &
  [ SYNSEM.LEX - ].

basic-extracted-comp-phrase := basic-extracted-arg-phrase & head-compositional &
  [ SYNSEM canonical-synsem &
	   [ LOCAL [ CAT [ VAL [ SUBJ #subj,
				 SPR #spr,
				 COMPS #comps ],
			   MC #mc ],
		     KEYS.MESSAGE #msg ],
	     LEX #lex ],
    HEAD-DTR [ SYNSEM 
	       [ LOCAL [ CAT [ VAL [ SUBJ #subj,
				     SPR #spr,
				     COMPS < gap &
					     [ NON-LOCAL.SLASH #slash ]
					     . #comps > ],
			       MC #mc ],
			 KEYS.MESSAGE #msg ],
		 LEX #lex,
		 NON-LOCAL.SLASH #slash ] ],
    C-CONT [ LISZT <! !>,
	     H-CONS <! !> ] ].

basic-extracted-subj-phrase := basic-extracted-arg-phrase &
  [ SYNSEM.LOCAL.CAT [ VAL [ SUBJ < >,
                             SPR < >,
			     COMPS < > ],
		       MC - ],
    HEAD-DTR.SYNSEM [ LOCAL.CAT [ VAL [ SUBJ < gap &
					       [ LOCAL #local & local &
						       [ CONT.INDEX ref-ind ] ] >,
					COMPS olist ],
				  MC na ],
		      NON-LOCAL.SLASH.LIST < #local > ] ].

head-mod-phrase := head-nexus-phrase &
  [ SYNSEM [ LOCAL [ CAT.VAL [ SUBJ #subj,
                               SPR #spr,
                               COMPS < > ],
                     KEYS.ALTKEY #altkey ],
	     MODIFIED hasmod ],
    HEAD-DTR.SYNSEM [ LOCAL [ CAT.VAL [ SUBJ #subj,
                                        SPR #spr,
                                        COMPS olist ],
                              KEYS.ALTKEY #altkey ],
                      NON-LOCAL [ REL 0-dlist ] ] ].

basic-extracted-adj-phrase := head-mod-phrase & head-only & phrasal.

extracted-adj-phrase := basic-extracted-adj-phrase &
  [ SYNSEM [ LOCAL [ CAT [ POSTHEAD #ph,
			   MC #mc ],
		     KEYS [ KEY #modkey,
                            MESSAGE #msg ] ],
	     NON-LOCAL.SLASH 1-dlist &
		   [ LIST < [ CAT [ POSTHEAD +,
				    HEAD [ MOD < [ LOCAL [ CAT [ HEAD #head,
                                                                 VAL #val,
                                                                 POSTHEAD #ph,
                                                                 MC #mc ],
                                                           CONT [ TOP #htop,
                                                                INDEX #hind ],
                                                           KEYS.KEY #modkey,
                                                           CTXT #ctxt ] ] > ],
				    VAL [ SUBJ olist,
                                          COMPS olist,
					  SPR olist ] ],
			      CONT.TOP #hand,
			      KEYS [ MESSAGE #msg ] ] > ] ],
    HEAD-DTR.SYNSEM canonical-synsem &
	   [ LOCAL local-basic &
		   [ CAT [ HEAD #head,
                           VAL #val & [ SUBJ < synsem-min &
                                               [ NON-LOCAL.SLASH 0-dlist ] > ],
			   POSTHEAD #ph,
                           MC #mc ],
                     CONT [ TOP #htop,
                            INDEX #hind ],
                     CTXT #ctxt ],
             NON-LOCAL.SLASH 0-dlist,
	     MODIFIED notmod ],
    C-CONT [ TOP #hand,
	     H-CONS <! !> ] ].

basic-head-mod-phrase-simple := head-mod-phrase & binary-headed-phrase &
  [ SYNSEM [ LOCAL [ CAT.MC #mc,
                     KEYS.MESSAGE #msg ],
	     NON-LOCAL [ SLASH [ LIST #first,
				 LAST #last ],
			 REL 0-dlist ] ],
    HEAD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD #head,
                                    VAL #val,
                                    POSTHEAD #ph,
                                    MC #hmc ],
                              AGR #agr,
			      CONT.INDEX #hind,
			      KEYS [ KEY #key,
                                     ALTKEY #altkey,
				     MESSAGE #hmsg ] ],
                      NON-LOCAL #nonloc &
			     [ SLASH [ LIST #middle,
				       LAST #last ] ],
                      MODIFIED #modif ],
    NON-HEAD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD [ MOD < [ LOCAL local & 
						       [ CAT [ HEAD #head,
                                                               VAL #val,
                                                               POSTHEAD #ph,
                                                               MC #hmc ],
							 AGR #agr,
							 CONT.INDEX #hind,
							 KEYS 
                                                          [ KEY #key,
                                                            ALTKEY #altkey,
							    MESSAGE #hmsg ] ],
						       NON-LOCAL #nonloc,
                                                       MODIFIED #modif ] > ],
					VAL [ COMPS olist,
					      SPR olist ],
                                        MC #mc ],
				  KEYS [ MESSAGE #msg ] ],
			  NON-LOCAL [ SLASH [ LIST #first,
					      LAST #middle ],
				      QUE 0-dlist & [ LIST null ] ] ],
    C-CONT.LISZT <! !> ].

head-mod-phrase-simple := basic-head-mod-phrase-simple &
  [ HEAD-DTR.SYNSEM.LOCAL.CONT.TOP #htop,
    NON-HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD.MOD < [ LOCAL.CONT.TOP #htop ] >,
                                CONT.TOP #hand ],
    C-CONT.TOP #hand ].

adj-head-phrase := basic-head-mod-phrase-simple & head-final &
  [ SYNSEM [ LOCAL.CAT.POSTHEAD #ph,
	     MODIFIED lmod & [ PERIPH #periph ],
             LEX #lex ],
    HEAD-DTR.SYNSEM [ LOCAL.CAT.POSTHEAD #ph,
                      LEX #lex ],
    NON-HEAD-DTR.SYNSEM [ LOCAL.CAT [ VAL.COMPS < > ],
			  NON-LOCAL [ SLASH 0-dlist,
				      REL 0-dlist ],
                          MODIFIED.PERIPH #periph ] ].

head-adj-phrase := basic-head-mod-phrase-simple & head-initial & phrasal &
  [ SYNSEM [ LOCAL.CAT.POSTHEAD +,
	     MODIFIED rmod ],
    HEAD-DTR.SYNSEM.MODIFIED notmod-or-rmod,
    NON-HEAD-DTR.SYNSEM [ LOCAL.CAT.POSTHEAD +,
			  NON-LOCAL.QUE 0-dlist ] ].

; We split head-adj-phrase and adj-head-phrase into two each,
; one for intersective modifiers and one for scopal modifiers, in order to
; get desired results for recursive modification as in "apparently difficult
; problem" (cf. Kasper '98).  This split is also used in generation, where
; we delay construction of intersective modification, but not scopal.

scopal-mod-phrase := head-mod-phrase-simple &
  [ NON-HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD.MOD < [ LOCAL scopal-mod ] >,
				CONT.INDEX #index ],
    C-CONT [ INDEX #index,
	     H-CONS <! !> ] ].

isect-mod-phrase := head-mod-phrase-simple &
  [ HEAD-DTR.SYNSEM.LOCAL [ CONT [ TOP #hand,
				   INDEX #index ],
			    KEYS.MESSAGE 0-dlist ],
    NON-HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD.MOD < [ LOCAL intersective-mod ] >,
				CONT.TOP #hand ],
    C-CONT [ INDEX #index,
	     H-CONS <! !> ] ].

adj-head-scop-phrase := adj-head-phrase & scopal-mod-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.POSTHEAD - ].
head-adj-scop-phrase := head-adj-phrase & scopal-mod-phrase &
  [ NON-HEAD-DTR.SYNSEM.NON-LOCAL.REL 0-dlist ].
adj-head-int-phrase := adj-head-phrase & isect-mod-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT [ POSTHEAD - ] ].
head-adj-int-phrase := head-adj-phrase & isect-mod-phrase.

